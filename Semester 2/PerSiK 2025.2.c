/*
Файл: PerSiK_main.cpp
Завдання на ПерСіК
Автор: Дарчук Г.С.
Завдання: реалізувати шифрування та дешифрування тексту за допомогою алгоритму, що чергує символи з двох половин рядка (шифр "Сендвіч")
Дата створення: 20.02.2025
*/

// пiдключення заголовних файлiв стандартних бiблiотек мови C
#include <stdio.h>
#include <Windows.h>
#include <string.h>

// оголошення масивів для зберігання тексту
char textNew[1024];  // масив для зашифрованого або розшифрованого тексту
char text[1024];     // масив для введеного тексту
int appType;         // змінна для визначення типу роботи програми (шифрування/дешифрування)

// функція для шифрування тексту
void encryption()
{
    int isOddNum = 0;  // флаг, що позначає, чи є кількість символів непарною
    int centrNum;       // змінна для визначення середини рядка

    // перевірка на непарну кількість символів
    if (strlen(text) % 2)
    {
        centrNum = strlen(text) / 2 + 1;  // обчислення середини для непарної кількості символів
        isOddNum = 1;  // встановлення флагу для непарної кількості
    }
    else centrNum = strlen(text) / 2;  // обчислення середини для парної кількості символів

    // цикл для шифрування тексту
    for (int i = 0; i < centrNum; i++)
    {
        textNew[i * 2] = text[i];  // перший символ з лівої половини
        if (i == centrNum - 1 && isOddNum) continue;  // пропускаємо середній символ у разі непарної кількості
        else textNew[i * 2 + 1] = text[i + centrNum];  // другий символ з правої половини
    }
}

// функція для дешифрування тексту
void decryption()
{
    int isOddNum = 0;  // флаг, що позначає, чи є кількість символів непарною
    int centrNum;       // змінна для визначення середини рядка
    // перевірка на непарну кількість символів
    if (strlen(text) % 2)
    {
        centrNum = strlen(text) / 2 + 1;  // обчислення середини для непарної кількості символів
        isOddNum = 1;  // встановлення флагу для непарної кількості
    }
    else centrNum = strlen(text) / 2;  // обчислення середини для парної кількості символів
    // цикл для дешифрування тексту
    for (int i = 0; i < centrNum; i++)
    {
        textNew[i] = text[i * 2];  // відновлюємо символи з лівої половини
        if (i == centrNum - 1 && isOddNum) continue;  // пропускаємо середній символ у разі непарної кількості
        else textNew[i + centrNum] = text[i * 2 + 1];  // відновлюємо символи з правої половини
    }
}

int main(void)
{
    // запит користувача на введення тексту
    printf("Введіть текст: ");
    scanf_s("%1023[^\n]", &text, (unsigned)_countof(text));  // введення тексту з можливістю ввести пробіли
    // запит типу роботи програми (шифрування чи дешифрування)
    printf("Введіть тип роботи програми (якщо 0 - шифрування, якщо 1 - дешифрування): ");
    scanf_s("%d", &appType);  // введення типу роботи програми
    // вибір функції шифрування чи дешифрування залежно від введеного значення
    switch (appType)
    {
    case 0:
        encryption();  // викликаємо функцію шифрування
        break;
    case 1:
        decryption();  // викликаємо функцію дешифрування
        break;
    default:
        // виведення помилки, якщо введено неправильний тип роботи
        printf("Помилка: неправильно введено тип виконання программи!");
        return 1;
    }
    // виведення результату (зашифрованого чи розшифрованого тексту)
    printf("Результат виконання програми: %s", textNew);
    return 0;
}
